// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: product_queries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCategory = `-- name: CreateCategory :one
INSERT INTO category
    (id, name, description, created_at)
    VALUES($1, $2, $3, $4)
    RETURNING id
`

type CreateCategoryParams struct {
	ID          pgtype.UUID
	Name        string
	Description string
	CreatedAt   pgtype.Timestamp
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createCategory,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.CreatedAt,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO product
    (id, 
    name, 
    low_stock_threshold, 
    image_id, 
    price, 
    tenant_id, 
    promotion, 
    safety_stock_level, 
    reorder_point, 
    min_lot, 
    max_lot, 
    fsn_classification, 
    width, 
    height, 
    length, 
    weight, 
    product_unit_of_measure_id
    )
    VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
    RETURNING id
`

type CreateProductParams struct {
	ID                     pgtype.UUID
	Name                   string
	LowStockThreshold      pgtype.Int4
	ImageID                pgtype.UUID
	Price                  pgtype.Numeric
	TenantID               pgtype.UUID
	Promotion              pgtype.Numeric
	SafetyStockLevel       pgtype.Int4
	ReorderPoint           pgtype.Int4
	MinLot                 pgtype.Int4
	MaxLot                 pgtype.Int4
	FsnClassification      pgtype.Text
	Width                  pgtype.Int4
	Height                 pgtype.Int4
	Length                 pgtype.Int4
	Weight                 pgtype.Int4
	ProductUnitOfMeasureID pgtype.UUID
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.ID,
		arg.Name,
		arg.LowStockThreshold,
		arg.ImageID,
		arg.Price,
		arg.TenantID,
		arg.Promotion,
		arg.SafetyStockLevel,
		arg.ReorderPoint,
		arg.MinLot,
		arg.MaxLot,
		arg.FsnClassification,
		arg.Width,
		arg.Height,
		arg.Length,
		arg.Weight,
		arg.ProductUnitOfMeasureID,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const createProductUnitsOfMeasure = `-- name: CreateProductUnitsOfMeasure :one
INSERT INTO product_unit_of_measure
    (id, name, description, created_at)
    VALUES($1, $2, $3, $4)
    RETURNING id
`

type CreateProductUnitsOfMeasureParams struct {
	ID          pgtype.UUID
	Name        string
	Description string
	CreatedAt   pgtype.Timestamp
}

func (q *Queries) CreateProductUnitsOfMeasure(ctx context.Context, arg CreateProductUnitsOfMeasureParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createProductUnitsOfMeasure,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.CreatedAt,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const createProductsCategories = `-- name: CreateProductsCategories :one
INSERT INTO products_categories
    (id, product_id, category_id)
    VALUES($1, $2, $3)
    RETURNING id
`

type CreateProductsCategoriesParams struct {
	ID         pgtype.UUID
	ProductID  pgtype.UUID
	CategoryID pgtype.UUID
}

func (q *Queries) CreateProductsCategories(ctx context.Context, arg CreateProductsCategoriesParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createProductsCategories, arg.ID, arg.ProductID, arg.CategoryID)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
